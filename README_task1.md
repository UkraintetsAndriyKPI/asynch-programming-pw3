# PracticeWork2 - task1

![task.png](task.png)

# Паралельне обчислення сум стовпців матриці

Програма містить дві реалізації для обчислення сум елементів кожного стовпця матриці з використанням багатопоточності в Java:
1. **Work Stealing**
2. **Work Dealing**

### Опис програми

Програма генерує випадкову матрицю розміру `sizeN`x`sizeM`, обчислює суми елементів кожного стовпця за допомогою двох підходів до паралельної обробки:
- **Work Stealing**: Завдання розбиваються на менші підзадачі, які обробляються потоками, і в разі потреби потоки можуть "красти" завдання від інших потоків, що допомагає забезпечити ефективну роботу.
- **Work Dealing**: Кожен потік відповідає за обчислення суми одного конкретного стовпця, і завдання не передаються між потоками.

### 1. **Work Stealing**
У цьому методі використовується `ForkJoinPool`, який дозволяє створювати задачі і паралельно їх обробляти, а також "красти" підзадачі в разі, якщо один із потоків має вільний час. Це дозволяє ефективно використовувати всі доступні потоки, особливо коли завдання складні і потребують часу.

- **Реалізація**: `RecursiveTask<int[]>` використовується для розбиття задачі на підзадачі, що дозволяє обчислювати суми стовпців рекурсивно.

### 2. **Work Dealing**
У цьому методі використовується пул потоків (`ExecutorService`), де кожен потік відповідає за обчислення суми одного стовпця матриці. Завдання не передаються між потоками, і кожен потік працює з конкретною частиною роботи.

- **Реалізація**: Створюється пул потоків, і кожен потік паралельно обчислює суму елементів у своєму стовпці.
- **Процес**:
    - Кожен потік обчислює суму елементів окремого стовпця.
    - Потоки працюють незалежно один від одного, виконуючи свою частину роботи.


### Різниця між методами **Work Stealing** і **Work Dealing**

- **Work Stealing**: Потоки можуть обмінюватися завданнями, що може бути ефективним для великих задач, де деякі потоки можуть бути вільними в процесі виконання.
    - **Переваги**: Більш ефективне використання всіх доступних потоків у разі, коли деякі частини задачі обробляються швидше, ніж інші.
    - **Недоліки**: Додаткові витрати на управління чергою завдань і їх крадіжку між потоками.

- **Work Dealing**: Кожен потік виконує своє завдання, і немає передачі роботи між потоками.
    - **Переваги**: Простота реалізації та відсутність додаткових витрат на управління завданнями.
    - **Недоліки**: Якщо одне завдання займає більше часу, інші потоки можуть залишатися вільними.

### Висновок:

Метод **Work Stealing** може бути більш ефективним у випадках, коли задача складна і потребує більш гнучкого розподілу роботи між потоками. У той час як **Work Dealing** є простішим у реалізації, але може бути менш ефективним. У моєму випадку вийшло так що методом з _"крадіжками"_ роботи виявився трішки швидшим.
##### Приклад результату одного з запусків:
```
(Work Stealing method) Результуючий масив усіх сум стовпців:
[1040, 1099, 1066, 1000, 1040, 992, 1066, 989, 1024, 1074, 1088, 891, 1028, 867, 973, 910, 1008, 1018, 935, 871]
(Work Stealing method) Час затрачений на виконання: 0.002879 секунд

(Work Dealing method) Результуючий масив усіх сум стовпців:
[1040, 1099, 1066, 1000, 1040, 992, 1066, 989, 1024, 1074, 1088, 891, 1028, 867, 973, 910, 1008, 1018, 935, 871]
(Work Dealing method) Час затрачений на виконання: 0.104416 секунд
```
**[<- back](README.md)**
